{"title":"Face Recognition By PCA","uid":"d2a98f67e0657f2a5b8d1883d9cac0d0","slug":"Face Recognition By PCA","date":"2022-01-08T12:43:05.000Z","updated":"2022-01-08T14:02:01.105Z","comments":true,"path":"api/articles/Face Recognition By PCA.json","keywords":null,"cover":"https://s4.ax1x.com/2022/01/08/7iFbC9.jpg","content":"<h1 id=\"PCA\"><a href=\"#PCA\" class=\"headerlink\" title=\"PCA\"></a>PCA</h1><p>​    PCA（Principal Component Analysis）是一种常用的数据分析方法。PCA通过线性变换将原始数据变换为一组各维度线性无关的表示，可用于提取数据的主要特征分量，常用于高维数据的降维。</p>\n<p>​    统计学上PCA的定义为用几个较少的综合指标来代替原来较多的指标，而这些较少的综合指标既能尽多地反映原来较多指标的有用信息，且相互之间又是无关的。作为一种建立在统计最优原则基础上的分析方法，主成分分析具有较长的发展历史。在1901年，Pearson首先将变换引入生物学领域，并重新对线性回归进行了分析，得出了变换的一种新形式。Hotelling于1933年则将其与心理测验学领域联系起来，把离散变量转变为无关联系数。在概率论理论建立的同时，主成分分析又单独出现，由Karhunen于1947年提出，随后Loeve于1963年将其归纳总结。因此，主成分分析也被称为K-L变换。</p>\n<p>​    PCA运算就是一种确定一个坐标系统的直交变换，在这个新的坐标系统下，变换数据点的方差沿新的坐标轴得到了最大化。这些坐标轴经常被称为是主成分。PCA运算是一个利用了数据集的统计性质的特征空间变换，这种变换在无损或很少损失了数据集的信息的情况下降低了数据集的维数。</p>\n<h1 id=\"灰度转换\"><a href=\"#灰度转换\" class=\"headerlink\" title=\"灰度转换\"></a>灰度转换</h1><p>​    首先我们知道一张图片的所有颜色都可以通过RGB值调节进行表示，如果是一张彩色图片则RBG值不一定相同，将彩色图片灰度化就是指的是将彩色图片变成黑白的，这时候的RBG三个通道的值是相同的，就是将一幅色彩图像转化为灰度图像的过程。</p>\n<p>​    彩色图像分为R，G，B三个分量，分别显示出红绿蓝等各种颜色，灰度化就是使彩色的R，G，B分量相等的过程。灰度值大的像素点比较亮（像素值最大为255，为白色），反之比较暗（像素最下为0，为黑色）这个过程就是指灰度化。</p>\n<p>​    对图像灰度化便于后续对图像的特征进行提取，以及得到图像的灰度曲线图。</p>\n<table>\n<thead>\n<tr>\n<th>最大值法</th>\n<th>取RGB三色分量中的最大值，即R=G=B=max(R,G,B)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>平均值法</td>\n<td>取RGB三色分量中的平均值，即R=G=B=(R+G+B)/3</td>\n</tr>\n<tr>\n<td>加权平均法</td>\n<td>按权取RGB三色分量的平均值，即R=G=B=WrR+WgG+WbB，当Wr=0.587，Wg=0.299,Wb=0.114时，效果更佳。</td>\n</tr>\n</tbody></table>\n<h2 id=\"最大值法代码表示：\"><a href=\"#最大值法代码表示：\" class=\"headerlink\" title=\"最大值法代码表示：\"></a>最大值法代码表示：</h2><pre class=\"line-numbers language-matlab\" data-language=\"matlab\"><code class=\"language-matlab\">im&#x3D;imread(&#39;RYan.jpg&#39;);\nfigure(&#39;name&#39;,&#39;原图像&#39;);\nimshow(im);\n[x,y,z]&#x3D;size(im);\nimmax&#x3D;ones(x,y);\n%最大值灰度图像\nfor i&#x3D;1:x\n  for j&#x3D;1:y\n  immax(i,j)&#x3D;max(im(i,j,:));\n  end\nend\nim(:,:,1)&#x3D;immax;\nim(:,:,2)&#x3D;immax;\nim(:,:,3)&#x3D;immax;\nfigure(&#39;name&#39;,&#39;最大值灰度图像&#39;);\nimshow(im);\ntitle(&#39;最大值灰度图像&#39;);</code></pre>\n\n<h2 id=\"平均值法代码表示：\"><a href=\"#平均值法代码表示：\" class=\"headerlink\" title=\"平均值法代码表示：\"></a>平均值法代码表示：</h2><pre class=\"line-numbers language-matlab\" data-language=\"matlab\"><code class=\"language-matlab\">im&#x3D;imread(&#39;RYan.jpg&#39;);\nfigure(&#39;name&#39;,&#39;原图像&#39;);\nimshow(im);\n%提取R、G、B三色分量\nimR&#x3D;im2double(im(:,:,1));\nimG&#x3D;im2double(im(:,:,2));\nimB&#x3D;im2double(im(:,:,3));\n%平均值灰度图像\n%取完平均值之后还要乘以255，将灰度值范围变回[0,255]并取整\nimRGB&#x3D;round((imR+imG+imB)&#x2F;3*255);\nim(:,:,1)&#x3D;imRGB;\nim(:,:,2)&#x3D;imRGB;\nim(:,:,3)&#x3D;imRGB;\nfigure(&#39;name&#39;,&#39;平均值灰度图像&#39;);\nimshow(im);\ntitle(&#39;平均值灰度图像&#39;);</code></pre>\n\n<h2 id=\"加权平均值法代码表示：\"><a href=\"#加权平均值法代码表示：\" class=\"headerlink\" title=\"加权平均值法代码表示：\"></a>加权平均值法代码表示：</h2><pre class=\"line-numbers language-matlab\" data-language=\"matlab\"><code class=\"language-matlab\">im&#x3D;imread(&#39;RYan.jpg&#39;);\nfigure(&#39;name&#39;,&#39;原图像&#39;);\nimshow(im);\n%提取R、G、B三色分量\nimR&#x3D;im2double(im(:,:,1));\nimG&#x3D;im2double(im(:,:,2));\nimB&#x3D;im2double(im(:,:,3));\n%加权平均值灰度图像\n%Wr&#x3D;0.587，Wg&#x3D;0.299,Wb&#x3D;0.114，加权平均后还要乘以255，将灰度值范围变回[0,255]并取整\nimRGB2&#x3D;round((0.587*imR+0.299*imG+0.114*imB)*255);\nim(:,:,1)&#x3D;imRGB2;\nim(:,:,2)&#x3D;imRGB2;\nim(:,:,3)&#x3D;imRGB2;\nfigure(&#39;name&#39;,&#39;加权平均值灰度图像&#39;);\nimshow(im);\ntitle(&#39;加权平均值灰度图像&#39;);</code></pre>\n\n<p>通过对图片用如下三种方法进行处理后，结论如下：</p>\n<p>1、最大值法灰度化后图像过于亮，丢失的图像细节较多，常用于对原本色调较暗的图像进行处理。</p>\n<p>2、加权平均值法灰度化后过于暗，不易于进行目标对象与背景区域的区分，常用于对原本色调较亮的图像进行处理。</p>\n<p>3、直接调用函数进行灰度化颜色依旧偏暗。</p>\n<p>4、均值的方法不仅计算便捷，且结果较佳。</p>\n<h1 id=\"图像滤波\"><a href=\"#图像滤波\" class=\"headerlink\" title=\"图像滤波\"></a>图像滤波</h1><p>​    滤波是数字图像处理中的一个基本操作，在信号处理领域可以说无处不在。图像滤波，即在尽量保留图像细节特征的条件下对目标图像的噪声进行抑制，通常是数字图像处理中不可缺少的操作，其处理效果的好坏将直接影响到后续运算和分析的效果。简单来说，图像滤波的根本目的是在图像中提取出人类感兴趣的特征。</p>\n<p>当我们观察一幅图像时，有两种处理方法：</p>\n<ol>\n<li><p>观察不同的灰度（或彩色值）在图像中的分布情况，即空间分布。</p>\n</li>\n<li><p>观察图像中的灰度（或彩色值）的变化情况，这涉及到频率方面的问题。</p>\n</li>\n</ol>\n<p>​    因此，图像滤波分为频域和空域滤波，简单来说，空域指用图像的灰度值来描述一幅图像；而频域指用图像灰度值的变化来描述一幅图像。而低通滤波器和高通滤波器的概念就是在频域中产生的。低通滤波器旨在去除图像中的高频成分，而高通滤波器则是去除了图像中的低频成分。</p>\n<p>​    这里简单记录以下低通滤波器中的均值和高斯滤波器（线性滤波器）、中值滤波器（非线性滤波器）；并针对以上滤波器的滤波效果进行简单的评估。</p>\n<p>​    消除图像中的噪声成分叫作图像的平滑化或低通滤波。信号或图像的能量大部分集中在幅度谱的低频和中频段是很常见的，而在较高频段，感兴趣的信息经常被噪声淹没。因此一个能降低高频成分幅度的滤波器就能够减弱噪声的影响。</p>\n<p>​    图像滤波的目的有两个:一是抽出对象的特征作为图像识别的特征模式；另一个是为适应图像处理的要求，消除图像数字化时所混入的噪声。当然，在设计低通滤波器时，要考虑到滤波对图像造成的细节丢失等问题。</p>\n<p>​    平滑滤波是低频增强的空间域滤波技术。它的目的有两类：一类是图像模糊；另一类是滤除图像噪声。空间域的平滑滤波一般采用简单平均法进行，就是求邻近像元点的平均灰度值或亮度值。邻域的大小与平滑的效果直接相关，邻域越大平滑的效果越好，但邻域过大，平滑会使边缘信息损失的越大，从而使输出的图像变得模糊，因此需合理选择邻域的大小。</p>\n<p>​    关于滤波器，一种形象的比喻法是：我们可以把滤波器想象成一个包含加权系数的窗口，当使用这个滤波器平滑处理图像时，就把这个窗口放到图像之上，透过这个窗口来看我们得到的图像。</p>\n<p>​    滤波器的种类有很多，在MATLAB中我们一般常用三种滤波器：均值滤波、中值滤波和高斯滤波。</p>\n<h2 id=\"均值滤波\"><a href=\"#均值滤波\" class=\"headerlink\" title=\"均值滤波\"></a>均值滤波</h2><p>​    均值滤波，顾名思义，是一种取平均值的滤波方法。</p>\n<p><a href=\"https://imgtu.com/i/7iZX7V\"><img src=\"https://s4.ax1x.com/2022/01/08/7iZX7V.md.png\" alt=\"7iZX7V.md.png\"></a></p>\n<p>​    如上图示，对于一个3<em>3大小的滤波器，每次取3</em>3大小范围内的平均值赋值给当前像素，特别注意，滤波器应该是归一化的，对于一个n*n大小的均值滤波器，其矩阵形式为：<br>$$<br>h_{\\text {mean }}=\\left[\\begin{array}{ccc}<br>\\frac{1}{n} &amp; \\cdots &amp; \\frac{1}{n} \\<br>\\vdots &amp; \\ddots &amp; \\vdots \\<br>\\frac{1}{n} &amp; \\cdots &amp; \\frac{1}{n}<br>\\end{array}\\right]=\\frac{1}{n}\\left[\\begin{array}{ccc}<br>1 &amp; \\cdots &amp; 1 \\<br>\\vdots &amp; \\ddots &amp; \\vdots \\<br>1 &amp; \\cdots &amp; 1<br>\\end{array}\\right] \\mid<br>$$<br>​    而在MATLAB中，h可以使用fspecial函数直接生成：</p>\n<pre class=\"line-numbers language-matlab\" data-language=\"matlab\"><code class=\"language-matlab\">h &#x3D; fspecial(&#39;average&#39;,hsize) returns an averaging filter h of size hsize.</code></pre>\n\n<p>​    显然，对于均值滤波而言，滤波器的Size越大，滤波后的图像就越模糊。下面是代码实现：</p>\n<pre class=\"line-numbers language-matlab\" data-language=\"matlab\"><code class=\"language-matlab\">img&#x3D;imread(&#39;RYan.jpg&#39;);\n%平均值法转灰度图片\nimR&#x3D;im2double(img(:,:,1));\nimG&#x3D;im2double(img(:,:,2));\nimB&#x3D;im2double(img(:,:,3));\nimRGB&#x3D;round((imR+imG+imB)&#x2F;3*255);\n%均值滤波\n[M , N] &#x3D; size(imRGB);%图片尺寸\nimg_result &#x3D; zeros(M, N);%预生成，提高速度\nmuban_size &#x3D; 3;%模板尺寸\nexpand_size &#x3D; floor(muban_size &#x2F; 2);%扩展尺寸\nmuban &#x3D; 1 &#x2F; (muban_size * muban_size) .* ones(muban_size, muban_size);\nexpand_img &#x3D; double(wextend(&#39;2D&#39;,&#39;zpd&#39;, imRGB, expand_size));%扩展0，转double为了矩阵运算\nfor i&#x3D;1:M\n  for j&#x3D;1:N\n    ave &#x3D; sum( sum( expand_img(i:i+muban_size-1,j:j+muban_size-1) .* muban)); %取出扩展元素与模板相乘,并求矩阵元素之和\n    img_result(i,j) &#x3D; ave;\n  end\nend\nimg_result &#x3D; uint8(img_result);%转int8，图像\nimg_GREY &#x3D; uint8(imRGB)\nfigure(&#39;name&#39;,&#39;均值滤波&#39;);\nsubplot(1 ,2, 1);\ntitle(&#39;原图像&#39;)\nimshow(img_GREY)\nsubplot(1 ,2, 2);\nimshow(img_result)\nmethod &#x3D; [&#39;模板大小为&#39; num2str(muban_size) &#39;，变化后的图像&#39;];\ntitle(method)</code></pre>\n\n<h2 id=\"中值滤波\"><a href=\"#中值滤波\" class=\"headerlink\" title=\"中值滤波\"></a>中值滤波</h2><p>​    中值滤波，顾名思义，是一种取中间值的滤波方法。</p>\n<p><a href=\"https://imgtu.com/i/7inKeI\"><img src=\"https://s4.ax1x.com/2022/01/08/7inKeI.png\" alt=\"7inKeI.png\"></a></p>\n<p>​    如上图示，对于一个3<em>3大小的<a href=\"https://so.csdn.net/so/search?q=%E6%BB%A4%E6%B3%A2%E5%99%A8\">滤波器</a>，每次取3</em>3大小范围内的中值赋值给当前像素。中值滤波对图像的影响主要是如下几点：（a）单独的一个像素会被消除；（b）单独的一条线会被消除；（c）阶跃边界保持不变；（d）拐角会被磨圆。</p>\n<p>​    所以中值滤波去除椒盐噪声效果较为理想，下面是代码实现：</p>\n<pre class=\"line-numbers language-matlab\" data-language=\"matlab\"><code class=\"language-matlab\">im &#x3D; imread(&#39;RYan.jpg&#39;);\n\n%平均值法转灰度图片\nimR&#x3D;im2double(im(:,:,1));\nimG&#x3D;im2double(im(:,:,2));\nimB&#x3D;im2double(im(:,:,3));\nimRGB&#x3D;round((imR+imG+imB)&#x2F;3*255);\n\n%中值滤波\n[M , N] &#x3D; size(imRGB);%图片尺寸\nimg_result &#x3D; zeros(M, N);%预生成，提高速度\n\nmuban_size &#x3D; 3;%模板尺寸\nexpand_size &#x3D; floor(muban_size &#x2F; 2);%扩展尺寸\nmuban &#x3D; ones(muban_size, muban_size);\n\n\nexpand_img &#x3D; double(wextend(&#39;2D&#39;,&#39;zpd&#39;, imRGB, expand_size));%扩展0，转double为了矩阵运算\n\nfor i&#x3D;1:M\n    for j&#x3D;1:N\n        mat &#x3D; expand_img(i:i+muban_size-1,j:j+muban_size-1) .* muban; %取出x1中从(i,j)开始的n行n列元素与模板相乘\n        mat &#x3D; mat(:);%转数组\n        mat &#x3D; sort(mat);%排序\n        if mod(muban_size, 2)&#x3D;&#x3D;1\n            img_result(i,j) &#x3D; mat(floor(muban_size*muban_size&#x2F;2)+1);%取中间\n        else\n            img_result(i,j) &#x3D; (mat(muban_size*muban_size&#x2F;2) + mat(muban_size*muban_size&#x2F;2+1))&#x2F;2;\n        end\n    end\nend\n\nimg_result &#x3D; uint8(img_result);%转int8，图像\nimg_GREY &#x3D; uint8(imRGB)\nfigure(&#39;name&#39;,&#39;中值滤波&#39;);\nsubplot(1 ,2, 1);\ntitle(&#39;原图像&#39;)\nimshow(img_GREY)\nsubplot(1 ,2, 2);\nimshow(img_result)\nda &#x3D; [&#39;模板大小为&#39; num2str(muban_size) &#39;，变化后的图像&#39;];\ntitle(da)\n</code></pre>\n\n<h2 id=\"高斯滤波\"><a href=\"#高斯滤波\" class=\"headerlink\" title=\"高斯滤波\"></a>高斯滤波</h2><p>​    数值图像处理中，高斯滤波主要可以使用两种方法实现。一种是离散化窗口滑窗卷积，另一种方法是通过傅里叶变化。在这我主要想说说第一种方法的高斯滤波。离散化窗口滑窗卷积的时，主要利用的是高斯核，高斯核一般是一个奇数的大小的高斯模板。常用的高斯模板有如下几种形式：</p>\n<p><a href=\"https://imgtu.com/i/7iuFns\"><img src=\"https://s4.ax1x.com/2022/01/08/7iuFns.png\" alt=\"7iuFns.png\"></a></p>\n<p>​    高斯模板中的参数是通过高斯函数计算出来的。计算高斯模板参数时，通过如下公式：<br>$$<br>G(x, y)=\\frac{1}{2 \\pi \\sigma^{2}} e^{-\\frac{x^{2}+y^{2}}{2 \\sigma^{2}}}<br>$$<br>​    其中，x的平方和y的平方分别表示的是邻域内其他像素与邻域内中心像素的距离，Sigmma代表的是标准差。</p>\n<p>​    代码实现：</p>\n<pre class=\"line-numbers language-matlab\" data-language=\"matlab\"><code class=\"language-matlab\">img&#x3D;imread(&#39;RYan.jpg&#39;);\n%平均值法转灰度图片\nimR&#x3D;im2double(img(:,:,1));\nimG&#x3D;im2double(img(:,:,2));\nimB&#x3D;im2double(img(:,:,3));\nimRGB&#x3D;round((imR+imG+imB)&#x2F;3*255);\n[M , N] &#x3D; size(imRGB);%保存图像尺寸\nimRGB&#x3D;im2double(imRGB);\nguss_filter_img&#x3D;imRGB;\nfor r &#x3D; 2:1:M-1\n    for c &#x3D; 2:1:N-1\n        guss_filter_img(r,c) &#x3D;(imRGB(r-1, c-1) + imRGB(r-1, c)*2 + imRGB(r-1, c+1) + imRGB(r, c-1)*2 + imRGB(r, c)*4 + imRGB(r, c+1)*2+ imRGB(r+1, c-1) + imRGB(r+1, c)*2 + imRGB(r+1, c+1))&#x2F; 16;\n    end\nend\nguss_filter_img &#x3D; uint8(guss_filter_img);%转int8，图像\nimgGREY &#x3D; uint8(imRGB);\nsubplot(1,2,1),imshow(imgGREY),title(&#39;原图像&#39;);%显示原始图像\nsubplot(1,2,2),imshow(guss_filter_img),title(&#39;method&#39;);</code></pre>\n\n<h2 id=\"三种滤波方式对比\"><a href=\"#三种滤波方式对比\" class=\"headerlink\" title=\"三种滤波方式对比\"></a>三种滤波方式对比</h2><p>​    中值滤波法是一种非线性平滑技术，它将每一像素点的灰度值设置为该点某邻域窗口内的所有像素点灰度值的中值。</p>\n<p>​    均值滤波是典型的线性滤波算法，它是指在图像上对目标像素给一个模板，该模板包括了其周围的临近像素（以目标像素为中心的周围8个像素，构成一个滤波模板，即去掉目标像素本身），再用模板中的全体像素的平均值来代替原来像素值。</p>\n<p>​    高斯滤波是一种线性平滑滤波，适用于消除高斯噪声，广泛应用于图像处理的减噪过程。通俗的讲，高斯滤波就是对整幅图像进行加权平均的过程，每一个像素点的值，都由其本身和邻域内的其他像素值经过加权平均后得到。高斯滤波的具体操作是：用一个模板（或称卷积、掩模）扫描图像中的每一个像素，用模板确定的邻域内像素的加权平均灰度值去替代模板中心像素点的值。</p>\n<p>​    图像经过中值滤波后，高斯噪声没有被完全去除，椒盐噪声几乎被完全去除，效果较好。经过均值滤波后不管是高斯噪声还是椒盐噪声大部分都没有被去除，只是稍微模糊化。经过高斯滤波后，高斯噪声和椒盐噪声几乎被很大程度的模糊化，原图好像被加上了一层蒙版。</p>\n<h1 id=\"PCA降维代码\"><a href=\"#PCA降维代码\" class=\"headerlink\" title=\"PCA降维代码\"></a>PCA降维代码</h1><p>​    前文已经讲述了PCA降维的数学原理，PCA人脸识别的代码如下：</p>\n<pre class=\"line-numbers language-matlab\" data-language=\"matlab\"><code class=\"language-matlab\">% PCA降维\n% 计算协方差矩阵\nCov &#x3D; img_matrix&#39; * img_matrix;\n% 特征值对角化\n[v, D] &#x3D; eig(Cov);\n[D, pos] &#x3D; sort(diag(D), &quot;descend&quot;);\nv &#x3D; v(pos, :);\nsave([train_imgpath &#39;&#x2F;&#39; &#39;v.mat&#39;], &#39;v&#39;);\n% 降维\nK &#x3D; 35;\nv &#x3D; importdata([train_imgpath &#39;&#x2F;&#39; &#39;v.mat&#39;], &#39;v&#39;);\ntrans &#x3D; v(1:K, :);\nsave([train_imgpath &#39;&#x2F;&#39; &#39;tsmatrix.mat&#39;], &#39;trans&#39;);\n%保存降维结果\ntmatrix &#x3D; img_matrix * trans&#39;;\nsave([train_imgpath &#39;&#x2F;&#39; &#39;tmatrix.mat&#39;], &#39;tmatrix&#39;);</code></pre>\n\n<p>欢迎邮件讨论<a href=\"mailto:1304711817@qq.com\">1304711817@qq.com</a></p>\n","feature":true,"text":"PCA​ PCA（Principal Component Analysis）是一种常用的数据分析方法。PCA通过线性变换将原始数据变换为一组各维度线性无关的表示，可用于提取数据的主要特征分量，常用于高维数据的降维。 ​ 统计学上PCA的定义为用几个较少的综合指标来代替原来较多的指...","link":"","photos":[],"count_time":{"symbolsCount":"8.6k","symbolsTime":"8 mins."},"categories":[{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","count":3,"path":"api/categories/Artificial-Intelligence.json"}],"tags":[{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","count":3,"path":"api/tags/Artificial-Intelligence.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#PCA\"><span class=\"toc-text\">PCA</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%81%B0%E5%BA%A6%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">灰度转换</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%80%E5%A4%A7%E5%80%BC%E6%B3%95%E4%BB%A3%E7%A0%81%E8%A1%A8%E7%A4%BA%EF%BC%9A\"><span class=\"toc-text\">最大值法代码表示：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B9%B3%E5%9D%87%E5%80%BC%E6%B3%95%E4%BB%A3%E7%A0%81%E8%A1%A8%E7%A4%BA%EF%BC%9A\"><span class=\"toc-text\">平均值法代码表示：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8A%A0%E6%9D%83%E5%B9%B3%E5%9D%87%E5%80%BC%E6%B3%95%E4%BB%A3%E7%A0%81%E8%A1%A8%E7%A4%BA%EF%BC%9A\"><span class=\"toc-text\">加权平均值法代码表示：</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9B%BE%E5%83%8F%E6%BB%A4%E6%B3%A2\"><span class=\"toc-text\">图像滤波</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2\"><span class=\"toc-text\">均值滤波</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2\"><span class=\"toc-text\">中值滤波</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%AB%98%E6%96%AF%E6%BB%A4%E6%B3%A2\"><span class=\"toc-text\">高斯滤波</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E7%A7%8D%E6%BB%A4%E6%B3%A2%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94\"><span class=\"toc-text\">三种滤波方式对比</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#PCA%E9%99%8D%E7%BB%B4%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">PCA降维代码</span></a></li></ol>","author":{"name":"JerryYan","slug":"blog-author","avatar":"https://z3.ax1x.com/2021/12/01/oJTH4U.png","link":"/","description":"A student from CQU","socials":{"github":"https://github.com/JY-JOKE","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/5584816151","zhihu":"","csdn":"https://blog.csdn.net/qq_29207457?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Marine Species Detection by YOLOv7","uid":"face3408614c8be8a20074e340a7f463","slug":"Marine Species Detection by YOLOv7","date":"2022-09-27T09:19:05.000Z","updated":"2022-09-27T03:42:01.987Z","comments":true,"path":"api/articles/Marine Species Detection by YOLOv7.json","keywords":null,"cover":"https://s1.ax1x.com/2022/09/27/xZtB01.png","text":"Marine Species Detection by YOLOv7Project OverviewWith the rapid development of deep learning in marine biological testing, its status in ma...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","count":3,"path":"api/categories/Artificial-Intelligence.json"}],"tags":[{"name":"Artificial Intelligence","slug":"Artificial-Intelligence","count":3,"path":"api/tags/Artificial-Intelligence.json"}],"author":{"name":"JerryYan","slug":"blog-author","avatar":"https://z3.ax1x.com/2021/12/01/oJTH4U.png","link":"/","description":"A student from CQU","socials":{"github":"https://github.com/JY-JOKE","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/5584816151","zhihu":"","csdn":"https://blog.csdn.net/qq_29207457?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"IELTS Speaking notes","uid":"0aa0465dcdf75184f7ed23532a52c943","slug":"IELTS Speaking notes","date":"2021-12-09T15:06:33.000Z","updated":"2021-12-09T15:17:24.916Z","comments":true,"path":"api/articles/IELTS Speaking notes.json","keywords":null,"cover":"https://s1.ax1x.com/2021/12/09/o4wDnf.png","text":"Some points of the IELTS Speaking: Discourse markers Positive: sure, definitely ,of course Negative: not at all, absolutely not, I am afraid...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"IELTS","slug":"IELTS","count":1,"path":"api/categories/IELTS.json"}],"tags":[{"name":"IELTS","slug":"IELTS","count":1,"path":"api/tags/IELTS.json"}],"author":{"name":"JerryYan","slug":"blog-author","avatar":"https://z3.ax1x.com/2021/12/01/oJTH4U.png","link":"/","description":"A student from CQU","socials":{"github":"https://github.com/JY-JOKE","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/5584816151","zhihu":"","csdn":"https://blog.csdn.net/qq_29207457?spm=1000.2115.3001.5343","juejin":"","customs":{}}},"feature":true}}